// Foundation for Sites by ZURB
// foundation.zurb.com
// Licensed under MIT Open Source

///
/// Replaced gloabl '$breakpoints' variable with '$zf-breakpoints' so it doesn't conflict with existing founnd in _settings.scss
///





////
/// _mixins.scss
////

/// Iterates through breakpoints defined in `$breakpoint-classes` and prints the CSS inside the mixin at each breakpoint's media query. Use this with the grid, or any other component that has responsive classes.
///
/// @param {Boolean} $small [true] - If `false`, the mixin will skip the `small` breakpoint. Use this with components that don't prefix classes with `small-`, only `medium-` and up.
@mixin -zf-each-breakpoint($small: true) {
  $map: $breakpoint-classes;

  @if not $small {
    $map: map-remove($map, small);
  }

  @each $size in $map {
    $-zf-size: $size !global;

    @include breakpoint($size) {
      @content;
    }
  }
}





////
/// _value.scss
////

// TODO: Remove this (it's used by the grid but is overkill)
/// Given a user-defined list of keywords and a list of possible keywords, find the ones that were passed in.
/// @access private
///
/// @param {List} $opts - List of values to find keywords in.
/// @param {List} $seeking - List of all possible keywords.
///
/// @returns {Map} A map of all keywords in $seeking. If a keyword was found in $opts, its value is true, otherwise false.
@function -zf-get-options($opts, $seeking) {
  @if type-of($opts) != 'list' {
    $opts: ($opts);
  }

  $map: ();
  @each $keyword in $seeking {
    $val: if(index($opts, $keyword) != null, true, false);
    $item: ($keyword: $val);
    $map: map-merge($map, $item);
  }

  @return $map;
}





////
/// _unit.scss
////

/// Removes the unit (e.g. px, em, rem) from a value, returning the number only.
///
/// @param {Number} $num - Number to strip unit from.
///
/// @returns {Number} The same number, sans unit.
@function strip-unit($num) {
  @return $num / ($num * 0 + 1);
}

/// Converts one or more pixel values into matching rem values.
///
/// @param {Number|List} $values - One or more values to convert. Be sure to separate them with spaces and not commas. If you need to convert a comma-separated list, wrap the list in parentheses.
/// @param {Number} $base [null] - The base value to use when calculating the `rem`. If you're using Foundation out of the box, this is 16px. If this parameter is `null`, the function will reference the `$base-font-size` variable as the base.
///
/// @returns {List} A list of converted values.
@function rem-calc($values, $base: null) {
  $rem-values: ();
  $count: length($values);

  // If no base is defined, defer to the global font size
  @if $base == null {
    $base: $global-font-size;
  }

  // If the base font size is a %, then multiply it by 16px
  // This is because 100% font size = 16px in most all browsers
  @if unit($base) == '%' {
    $base: ($base / 100%) * 16px;
  }

  @if $count == 1 {
    @return -zf-to-rem($values, $base);
  }

  @for $i from 1 through $count {
    $rem-values: append($rem-values, -zf-to-rem(nth($values, $i), $base));
  }

  @return $rem-values;
}

// Converts a unitless, pixel, or rem value to em, for use in breakpoints.
@function -zf-bp-to-em($value) {
  // Pixel and unitless values are converted to rems
  @if unit($value) == 'px' or unitless($value) {
    $value: rem-calc($value, $base: 16px);
  }

  // Then the value is converted to ems
  @return strip-unit($value) * 1em;
}

/// Converts a pixel value to matching rem value. *Any* value passed, regardless of unit, is assumed to be a pixel value. By default, the base pixel value used to calculate the rem value is taken from the `$global-font-size` variable.
/// @access private
///
/// @param {Number} $value - Pixel value to convert.
/// @param {Number} $base [null] - Base for pixel conversion.
///
/// @returns {Number} A number in rems, calculated based on the given value and the base pixel value. rem values are passed through as is.
@function -zf-to-rem($value, $base: null) {
  // Check if the value is a number
  @if type-of($value) != 'number' {
    @warn inspect($value) + ' was passed to rem-calc(), which is not a number.';
    @return $value;
  }

  // Calculate rem if units for $value is not rem
  @if unit($value) != 'rem' {
    $value: strip-unit($value) / strip-unit($base) * 1rem;
  }

  // Turn 0rem into 0
  @if $value == 0rem {
    $value: 0;
  }

  @return $value;
}





////
/// _global.scss
////

/// Font size attribute applied to `<html>` and `<body>`. We use 100% by default so the value is inherited from the user's browser settings.
/// @type Number
$global-font-size: 100% !default;

/// Global width of your site. Used by the grid to determine row width.
/// @type Number
$global-width: rem-calc(1200) !default;

/// Sets the text direction of the CSS. Can be either `ltr` or `rtl`.
$global-text-direction: ltr !default;

// Internal variables used for text direction
$global-left: if($global-text-direction == rtl, right, left);
$global-right: if($global-text-direction == rtl, left, right);





////
/// _breakpoint.scss
////

/// A list of named breakpoints. You can use these with the `breakpoint()` mixin to quickly create media queries.
/// @type Map
$zf-breakpoints: (
  small: 0,
  medium: 600px,
  large: 768px,
  xlarge: 1024px,
  xxlarge: 1200px,
) !default;

/// All of the names in this list will be output as classes in your CSS, like `.small-12`, `.medium-6`, and so on. Each value in this list must also be in the `$zf-breakpoints` map.
/// @type List
$breakpoint-classes: (small medium large xlarge xxlarge) !default;

/// Generates a media query string matching the input value. Refer to the documentation for the `breakpoint()` mixin to see what the possible inputs are.
///
/// @param {Keyword|Number} $val [small] - Breakpoint name, or px, rem, or em value to process.
@function breakpoint($val: small) {
  // Size or keyword
  $bp: nth($val, 1);
  // Value for max-width media queries
  $bp-max: 0;
  // Direction of media query (up, down, or only)
  $dir: if(length($val) > 1, nth($val, 2), up);
  // Eventual output
  $str: '';
  // Is it a named media query?
  $named: false;

  // Orientation media queries have a unique syntax
  @if $bp == 'landscape' or $bp == 'portrait' {
    @return '(orientation: #{$bp})';
  }
  @else if $bp == 'retina' {
    @return '(-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi)';
  }

  // Try to pull a named breakpoint out of the $zf-breakpoints map
  @if type-of($bp) == 'string' {
    @if map-has-key($zf-breakpoints, $bp) {
      @if $dir == 'only' or $dir == 'down' {
        $bp-max: -zf-map-next($zf-breakpoints, $bp);
      }

      $bp: map-get($zf-breakpoints, $bp);
      $named: true;
    }
    @else {
      $bp: 0;
    }
  }

  // Convert any pixel, rem, or unitless value to em
  $bp: -zf-bp-to-em($bp);
  @if $bp-max {
    $bp-max: -zf-bp-to-em($bp-max) - (1/16);
  }

  // Conditions to skip media query creation
  // - It's a named breakpoint that resolved to "0 down" or "0 up"
  // - It's a numeric breakpoint that resolved to "0 " + anything
  @if $bp > 0em or $dir == 'only' or $dir == 'down' {
    // `only` ranges use the format `(min-width: n) and (max-width: n)`
    @if $dir == 'only' {
      // Only named media queries can have an "only" range
      @if $named == true {
        // Only use "min-width" if the floor is greater than 0
        @if $bp > 0em {
          $str: $str + '(min-width: #{$bp})';

          // Only add "and" to the media query if there's a ceiling
          @if $bp-max != null {
            $str: $str + ' and ';
          }
        }

        // Only use "max-width" if there's a ceiling
        @if $bp-max != null {
          $str: $str + '(max-width: #{$bp-max})';
        }
      }
      @else {
        @warn 'breakpoint(): Only named media queries can have an `only` range.';
      }
    }

    // `down` ranges use the format `(max-width: n)`
    @else if $dir == 'down' {
      $max: if($named, $bp-max, $bp);

      // Skip media query creation if input value is exactly "0 down",
      // unless the function was called as "small down", in which case it's just "small only"
      @if $named or $bp > 0em {
        @if $max != null {
          $str: $str + '(max-width: #{$max})';
        }
      }
    }

    // `up` ranges use the format `(min-width: n)`
    @else if $bp > 0em {
      $str: $str + '(min-width: #{$bp})';
    }
  }

  @return $str;
}

/// Wraps a media query around the content you put inside the mixin. This mixin accepts a number of values:
///  - If a string is passed, the mixin will look for it in the `$zf-breakpoints` map, and use a media query there.
///  - If a pixel value is passed, it will be converted to an em value using `$global-font-size` as the base.
///  - If a rem value is passed, the unit will be changed to em.
///  - If an em value is passed, the value will be used as-is.
///
/// @param {Keyword|Number} $value - Breakpoint name, or px, rem, or em value to process.
///
/// @output If the breakpoint is "0px and larger", outputs the content as-is. Otherwise, outputs the content wrapped in a media query.
@mixin breakpoint($value) {
  $str: breakpoint($value);

  // If $str is still an empty string, no media query is needed
  @if $str == '' {
    @content;
  }

  // Otherwise, wrap the content in a media query
  @else {
    @media screen and #{$str} {
      @content;
    }
  }
}

/// Convers the breakpoints map to a URL-encoded string, like this: `key1=value1&key2=value2`. The value is then dropped into the CSS for a special `<meta>` tag, which is read by the Foundation JavaScript. This is how we transfer values from Sass to JavaScript, so they can be defined in one place.
/// @access private
///
/// @param {Map} $map - Map to convert.
///
/// @returns {String} A string containing the map's contents.
@function -zf-bp-serialize($map) {
  $str: '';
  @each $key, $value in $map {
    $str: $str + $key + '=' + -zf-bp-to-em($value) + '&';
  }
  $str: str-slice($str, 1, -2);

  @return $str;
}

/// Find the next key in a map.
/// @access private
///
/// @param {Map} $map - Map to traverse.
/// @param {Mixed} $key - Key to use as a starting point.
///
/// @returns {Mixed} The value for the key after `$key`, if `$key` was found. If `$key` was not found, or `$key` was the last value in the map, returns `null`.
@function -zf-map-next($map, $key) {
  // Store the values of the map as a list, so we can access them with nth
  $values: map-values($map);

  // Ghetto for loop
  $i: 1;
  $found: false;
  @each $val in map-keys($map) {
    @if $found == false {
      @if ($key == $val) {
        $found: true;
      }
      $i: $i + 1;
    }
  }

  // If the key doesn't exist, or it's the last key in the map, return null
  @if $i > length($map) {
    @return null;
  }
  // Otherwise, return the value
  @else {
    @return nth($values, $i);
  }
}

/// Get a value for a breakpoint from a responsive config map. If the config map has the key `$value`, the exact breakpoint value is returned. If the config map does *not* have the breakpoint, the value matching the next lowest breakpoint in the config map is returned.
/// @access private
///
/// @param {Map} $map - Input config map.
/// @param {Keyword} $value - Breakpoint name to use.
///
/// @return {Mixed} The corresponding breakpoint value.
@function -zf-get-bp-val($map, $value) {
  // Check if the breakpoint name exists globally
  @if not map-has-key($zf-breakpoints, $value) {
    @return null;
  }
  // Check if the breakpoint name exists in the local config map
  @else if map-has-key($map, $value) {
    // If it does, just return the value
    @return map-get($map, $value);
  }
  // Otherwise, find the next lowest breakpoint and return that value
  @else {
    $anchor: null;
    $found: false;

    @each $key, $val in $zf-breakpoints {
      @if not $found {
        @if map-has-key($map, $key) {
          $anchor: $key;
        }
        @if $key == $value {
          $found: true;
        }
      }
    }

    @return map-get($map, $anchor);
  }
}

// Legacy breakpoint variables
// These will be removed in 6.2
$small-up: null;
$small-only: null;
$medium-up: null;
$medium-only: null;
$large-up: null;
$large-only: null;
$xlarge-up: null;
$xlarge-only: null;
$xxlarge-up: null;
$xxlarge-only: null;

@if map-has-key($zf-breakpoints, small) {
  $small-up: screen;
  $small-only: unquote('screen and #{breakpoint(small only)}');
}

@if map-has-key($zf-breakpoints, medium) {
  $medium-up: unquote('screen and #{breakpoint(medium)}');
  $medium-only: unquote('screen and #{breakpoint(medium only)}');
}

@if map-has-key($zf-breakpoints, large) {
  $large-up: unquote('screen and #{breakpoint(large)}');
  $large-only: unquote('screen and #{breakpoint(large only)}');
}

@if map-has-key($zf-breakpoints, xlarge) {
  $xlarge-up: unquote('screen and #{breakpoint(xlarge)}');
  $xlarge-only: unquote('screen and #{breakpoint(xlarge only)}');
}

@if map-has-key($zf-breakpoints, xxlarge) {
  $xxlarge-up: unquote('screen and #{breakpoint(xxlarge)}');
}





////
/// _grid.scss
////

/// The maximum width of a row.
/// @type Number
$grid-row-width: $global-width !default;

/// The default column count of a grid. Changing this value affects the logic of the grid mixins, and the number of CSS classes output.
/// @type Number
$grid-column-count: 12 !default;

// The amount of space between columns. Remove this in 6.2.
// @type Number
$grid-column-gutter: 24px !default;

/// The amount of space between columns at different screen sizes.
/// @type Map
/// @since 6.1.0
$grid-column-responsive-gutter: (
  small: 24px,
  // medium: 24px,
) !default;

/// If `true`, the last column in a row will align to the opposite edge of the row.
/// @type Boolean
$grid-column-align-edge: true !default;

// Internal value to store the end column float direction
$-zf-end-float: if($grid-column-align-edge, $global-right, $global-left);

/// The highest number of `.x-up` classes available when using the block grid CSS.
/// @type Number
$block-grid-max: 8 !default;

// @import 'row';
// @import 'column';
// @import 'size';
// @import 'position';
// @import 'gutter';
// @import 'classes';
// @import 'layout';

// @import 'flex-grid';





////
/// _row.scss
////

/// Change the behavior of columns defined inside this mixin to use a different column count.
/// @content
///
/// @param {Number} $columns - Number of columns to use.
/// @param {Boolean} $root [false]
///   If `false`, selectors inside this mixin will nest inside the parent selector.
///   If `true`, selectors will not nest.
@mixin grid-context(
  $columns,
  $root: false
) {
  // Store the current column count so it can be re-set later
  $old-grid-column-count: $grid-column-count;
  $grid-column-count: $columns !global;

  @if $root {
    @at-root { @content; }
  }
  @else {
    @content;
  }

  // Restore the old column count
  $grid-column-count: $old-grid-column-count;
}

/// Creates a grid row.
/// @content
///
/// @param {Number} $columns [null] - Column count for this row. `null` will use the default column count.
/// @param {Keywords} $behavior [null]
///   Modifications to the default grid styles. `nest` indicates the row will be placed inside another row. `collapse` indicates that the columns inside this row will not have padding. `nest collapse` combines both behaviors.
/// @param {Number} $width [$grid-row-width] - Maximum width of the row.
/// @param {Boolean} $cf [true] - Whether or not to include a clearfix.
/// @param {Number} $gutter [$grid-column-gutter] - Gutter to use when inverting margins, in case the row is nested.
@mixin grid-row(
  $columns: null,
  $behavior: null,
  $width: $grid-row-width,
  $cf: true,
  $gutter: $grid-column-gutter
) {
  $behavior: -zf-get-options($behavior, nest collapse);
  $margin: auto;

  @if map-get($behavior, nest) {
    @include grid-row-nest($gutter);

    @if map-get($behavior, collapse) {
      margin-left: 0;
      margin-right: 0;
    }
  }
  @else {
    $margin: rem-calc($gutter) / 2 * -1;
    max-width: $width;
    margin-left: $margin;
    margin-right: $margin;
  }

  @if $cf {
    @include clearfix;
  }

  @if $columns != null {
    @include grid-context($columns) {
      @content;
    }
  }
}

/// Inverts the margins of a row to nest it inside of a column.
///
/// @param {Map|null} $gutter [null] - Gutter value to use when inverting the margins. Set to `null` to refer to the responsive gutter settings.
@mixin grid-row-nest($gutter: null) {
  @if $gutter != null {
    $margin: rem-calc($gutter) / 2 * -1;
    margin-left: $margin;
    margin-right: $margin;
  }
  @else {
    @each $breakpoint, $value in $grid-column-responsive-gutter {
      $margin: rem-calc($value) / 2 * -1;

      @include breakpoint($breakpoint) {
        margin-left: $margin;
        margin-right: $margin;
      }
    }
  }
}





////
/// _column.scss
////

/// Calculates the width of a column based on a number of factors.
///
/// @param {Number|List} $columns
///   Width of the column. Accepts multiple values:
///   - A percentage value will make the column that exact size.
///   - A single digit will make the column span that number of columns wide, taking into account the column count of the parent row.
///   - A string of the format "x of y" will make a column that is *x* columns wide, assuming *y* total columns for the parent.
///
/// @returns {Number} A calculated percentage value.
@function grid-column($columns) {
  $width: 0%;

  // Parsing percents, decimals, and column counts
  @if type-of($columns) == 'number' {
    @if unit($columns) == '%' {
      $width: $columns;
    }
    @else if $columns < 1 {
      $width: percentage($columns);
    }
    @else {
      $width: percentage($columns / $grid-column-count);
    }
  }

  // Parsing "n of n" expressions
  @else if type-of($columns) == 'list' {
    @if length($columns) != 3 {
      @error 'Wrong syntax for grid-column(). Use the format "n of n".';
    }
    @else {
      $width: percentage(nth($columns, 1) / nth($columns, 3));
    }
  }

  // Anything else is incorrect
  @else {
    @error 'Wrong syntax for grid-column(). Use a number, decimal, percentage, or "n of n".';
  }

  @return $width;
}

/// Creates a grid column.
///
/// @param {Mixed} $columns [$grid-column-count] - Width of the column. Refer to the `grid-column()` function to see possible values.
/// @param {Number} $gutter [$grid-column-gutter] - Spacing between columns.
@mixin grid-column(
  $columns: $grid-column-count,
  $gutter: $grid-column-gutter
) {
  @if $gutter != null {
    $gutter: rem-calc($gutter) / 2;
  }
  @else {
    @each $breakpoint, $gutter in $grid-column-responsive-gutter {
      $padding: rem-calc($gutter) / 2;

      @include breakpoint($breakpoint) {
        padding-left: $padding;
        padding-right: $padding;
      }
    }
  }

  @include grid-column-size($columns);
  float: $global-left;
  padding-left: $gutter;
  padding-right: $gutter;

  @if $grid-column-align-edge {
    &:last-child:not(:first-child) {
      float: $global-right;
    }
  }
}

/// Creates a grid column row. This is the equivalent of adding `.row` and `.column` to the same element.
///
/// @param {Number} $gutter [$grid-column-gutter] - Width of the gutters on either side of the column row.
@mixin grid-column-row(
  $gutter: $grid-column-gutter
) {
  @include grid-row;
  @include grid-column($gutter: $gutter);

  &,
  &:last-child {
    float: none;
  }
}

/// Shorthand for `grid-column()`.
/// @alias grid-column
@function grid-col(
  $columns: $grid-column-count
) {
  @return grid-column($columns);
}

/// Shorthand for `grid-column()`.
/// @alias grid-column
@mixin grid-col(
  $columns: $grid-column-count,
  $gutter: $grid-column-gutter
) {
  @include grid-column($columns, $gutter);
}

/// Shorthand for `grid-column-row()`.
/// @alias grid-column-row
@mixin grid-col-row(
  $gutter: $grid-column-gutter
) {
  @include grid-column-row($gutter);
}





////
/// _size.scss
////

/// Set the width of a grid column.
///
/// @param {Number|List} $width [$grid-column-count] - Width to make the column. You can pass in any value accepted by the `grid-column()` function, such as `6`, `50%`, or `1 of 2`.
@mixin grid-column-size(
  $columns: $grid-column-count
) {
  width: grid-column($columns);
}

/// Shorthand for `grid-column-size()`.
/// @alias grid-column-size
@mixin grid-col-size(
  $columns: $grid-column-count
) {
  @include grid-column-size($columns);
}





////
/// _position.scss
////

/// Reposition a column.
///
/// @param {Number} $position - Direction and amount to move. The column will move equal to the width of the column count specified. A positive number will push the column to the right, while a negative number will pull it to the left.
@mixin grid-column-position($position) {
  @if type-of($position) == 'number' {
    $offset: percentage($position / $grid-column-count);

    position: relative;
    #{$global-left}: $offset;
  }
  @else if $position == center {
    float: none;
    margin-left: auto;
    margin-right: auto;
  }
  @else {
    @warn 'Wrong syntax for grid-column-position(). Enter a positive or negative number, or center.';
  }
}

/// Reset a position definition.
@mixin grid-column-unposition {
  position: static;
  margin-left: 0;
  margin-right: 0;
  float: left;
}

/// Offsets a column to the right by `$n` columns.
/// @param {Number|List} $n - Width to offset by. You can pass in any value accepted by the `grid-column()` mixin, such as `6`, `50%`, or `1 of 2`.
@mixin grid-column-offset($n) {
  margin-#{$global-left}: grid-column($n);
}

/// Disable the default behavior of the last column in a row aligning to the opposite edge.
@mixin grid-column-end {
  // This extra specificity is required for the property to be applied
  &:last-child:last-child {
    float: $global-left;
  }
}

/// Shorthand for `grid-column-position()`.
/// @alias grid-column-position
@mixin grid-col-pos($position) {
  @include grid-column-position($position);
}

/// Shorthand for `grid-column-unposition()`.
/// @alias grid-column-unposition
@mixin grid-col-unpos {
  @include grid-column-unposition;
}

/// Shorthand for `grid-column-offset()`.
/// @alias grid-column-offset
@mixin grid-col-off($n) {
  @include grid-column-offset($n);
}

/// Shorthand for `grid-column-end()`.
/// @alias grid-column-end
@mixin grid-col-end {
  @include grid-column-end;
}





////
/// _gutter.scss
////

/// Collapse the gutters on a column by removing the padding. **Note:** only use this mixin within a breakpoint. To collapse a column's gutters on all screen sizes, use the `$gutter` parameter of the `grid-column()` mixin instead.
@mixin grid-column-collapse {
  padding-left: 0;
  padding-right: 0;
}

/// Un-collapse the gutters on a column by re-adding the padding.
///
/// @param {Number} $gutter [$grid-column-gutter] - Spacing between columns.
@mixin grid-column-uncollapse($gutter: $grid-column-gutter) {
  $gutter: rem-calc($gutter) / 2;
  padding-left: $gutter;
  padding-right: $gutter;
}

/// Shorthand for `grid-column-collapse()`.
/// @alias grid-column-collapse
@mixin grid-col-collapse {
  @include grid-column-collapse;
}

/// Shorthand for `grid-column-uncollapse()`.
/// @alias grid-column-uncollapse
@mixin grid-col-uncollapse($gutter: $grid-column-gutter) {
  @include grid-column-uncollapse($gutter);
}





////
/// _classes.scss
////

/// Outputs CSS classes for the grid.
/// @access private
@mixin foundation-grid(
  $row: 'row',
  $column: 'column',
  $column-row: 'column-row',
  $push: 'push',
  $pull: 'pull',
  $center: 'centered',
  $uncenter: 'uncentered',
  $collapse: 'collapse',
  $uncollapse: 'uncollapse',
  $offset: 'offset',
  $end: 'end',
  $expanded: 'expanded'
) {
  // Row
  .#{$row} {
    @include grid-row;

    // Collapsing
    &.#{$collapse} {
      > .#{$column} { @include grid-col-collapse; }
    }

    // Nesting
    & & {
      @if $grid-column-gutter == null {
        @each $breakpoint, $gutter in $grid-column-responsive-gutter {
          @include breakpoint($breakpoint) {
            @include grid-row-nest($gutter);
          }
        }
      }
      @else {
        @include grid-row-nest($grid-column-gutter);
      }

      &.#{$collapse} {
        margin-left: 0;
        margin-right: 0;
      }
    }

    // Expanded (full-width) row
    &.#{$expanded} {
      max-width: none;

      .#{$row} {
        margin-left: auto;
        margin-right: auto;
      }
    }
  }

  // Column
  .#{$column} {
    @include grid-col;

    @if $grid-column-align-edge {
      &.#{$end} {
        @include grid-col-end;
      }
    }
  }

  // Column row
  // The double .row class is needed to bump up the specificity
  .#{$column}.#{$row}.#{$row} {
    float: none;

    // To properly nest a column row, padding and margin is removed
    .#{$row} & {
      padding-left: 0;
      padding-right: 0;
      margin-left: 0;
      margin-right: 0;
    }
  }

  @include -zf-each-breakpoint {
    @for $i from 1 through $grid-column-count {
      // Column width
      .#{$-zf-size}-#{$i} {
        @include grid-col-size($i);
      }

      // Source ordering
      @if $i < $grid-column-count {
        .#{$-zf-size}-#{$push}-#{$i} {
          @include grid-col-pos($i);
        }

        .#{$-zf-size}-#{$pull}-#{$i} {
          @include grid-col-pos(-$i);
        }
      }

      // Offsets
      $o: $i - 1;

      .#{$-zf-size}-#{$offset}-#{$o} {
        @include grid-col-off($o);
      }
    }

    // Block grid
    @for $i from 1 through $block-grid-max {
      .#{$-zf-size}-up-#{$i} {
        @include grid-layout($i, ".#{$column}");
      }
    }

    // Responsive collapsing
    .#{$-zf-size}-#{$collapse} {
      > .#{$column} { @include grid-col-collapse; }

      .#{$row} {
        margin-left: 0;
        margin-right: 0;
      }
    }

    .#{$-zf-size}-#{$uncollapse} {
      $gutter: null;

      @if $grid-column-gutter {
        $gutter: $grid-column-gutter;
      }
      @else {
        $gutter: -zf-get-bp-val($grid-column-responsive-gutter, $-zf-size);
      }
      > .#{$column} { @include grid-col-uncollapse($gutter); }
    }

    // Positioning
    .#{$-zf-size}-#{$center} {
      @include grid-col-pos(center);
    }

    // Gutter adjustment
    .#{$-zf-size}-#{$uncenter},
    .#{$-zf-size}-#{$push}-0,
    .#{$-zf-size}-#{$pull}-0 {
      @include grid-col-unpos;
    }
  }

  @if $column == 'column' {
    .columns {
      // scss-lint:disable PlaceholderInExtend
      @extend .column;
    }
  }
}





////
/// _layout.scss
////

/// Sizes child elements so that `$n` number of items appear on each row.
///
/// @param {Number} $n - Number of elements to display per row.
/// @param {String} $selector ['.column'] - Selector(s) to use for child elements.
@mixin grid-layout(
  $n,
  $selector: '.column'
) {
  & > #{$selector} {
    width: percentage(1/$n);
    float: $global-left;

    &:nth-of-type(1n) {
      clear: none;
    }

    &:nth-of-type(#{$n}n+1) {
      clear: both;
    }

    &:last-child {
      float: left;
    }
  }
}





////
/// _flex-grid.scss
////

$-zf-flex-justify: (
  'left': flex-start,
  'right': flex-end,
  'center': center,
  'justify': space-between,
  'spaced': space-around,
);

$-zf-flex-align: (
  'top': flex-start,
  'bottom': flex-end,
  'middle': center,
  'stretch': stretch,
);

/// Creates a container for a flex grid row.
///
/// @param {Keyword|List} $behavior [null]
///   Modifications to the default grid styles. `nest` indicates the row will be placed inside another row. `collapse` indicates that the columns inside this row will not have padding. `nest collapse` combines both behaviors.
/// @param {Number} $width [$grid-row-width] - Maximum width of the row.
/// @param {Number} $columns [null] - Number of columns to use for this row. If set to `null` (the default), the global column count will be used.
/// @param {Boolean} $base [true] - Set to `false` to prevent basic styles from being output. Useful if you're calling this mixin on the same element twice, as it prevents duplicate CSS output.
/// @param {Number} $gutter [$grid-column-gutter] - Gutter to use when inverting margins, in case the row is nested.
@mixin flex-grid-row(
  $behavior: null,
  $width: $grid-row-width,
  $columns: null,
  $base: true,
  $gutter: $grid-column-gutter
) {
  $behavior: -zf-get-options($behavior, nest collapse);
  $margin: auto;

  @if map-get($behavior, nest) {
    @include grid-row-nest($gutter);

    @if map-get($behavior, collapse) {
      margin-left: 0;
      margin-right: 0;
    }
  }
  @else {
    max-width: $width;
    margin-left: auto;
    margin-right: auto;
  }

  @if $base {
    display: flex;
    flex-flow: row wrap;
  }

  @if $columns != null {
    @include grid-context($columns, $base) {
      @content;
    }
  }
}

/// Calculates the `flex` property for a flex grid column. It accepts all of the same values as the basic `grid-column()` function, along with two extras:
///   - `null` (the default) will make the column expand to fill space.
///   - `shrink` will make the column contract, so it only takes up the horizontal space it needs.
///
/// @param {Mixed} $columns [null] - Width of the column.
@function flex-grid-column($columns: null) {
  // scss-lint:disable ZeroUnit
  $flex: 1 1 0px;

  @if $columns == shrink {
    $flex: 0 0 auto;
  }
  @else if $columns != null {
    $flex: 0 0 grid-column($columns);
  }

  @return $flex;
}

/// Creates a column for a flex grid. By default, the column will stretch to the full width of its container, but this can be overridden with sizing classes, or by using the `unstack` class on the parent flex row.
///
/// @param {Mixed} $columns [null] - Width of the column. Refer to the `flex-grid-column()` function to see possible values.
/// @param {Number} $gutter [$grid-column-gutter] - Space between columns, added as a left and right padding.
@mixin flex-grid-column(
  $columns: null,
  $gutter: $grid-column-gutter
) {
  @if $gutter != null {
    $gutter: rem-calc($gutter) / 2;
  }
  @else {
    @each $breakpoint, $gutter in $grid-column-responsive-gutter {
      $padding: rem-calc($gutter) / 2;

      @include breakpoint($breakpoint) {
        padding-left: $padding;
        padding-right: $padding;
      }
    }
  }

  flex: flex-grid-column($columns);
  padding-left: $gutter;
  padding-right: $gutter;

  // max-width fixes IE 10/11 not respecting the flex-basis property
  @if $columns != null and $columns != shrink {
    max-width: grid-column($columns);
  }
}

/// Changes the source order of a flex grid column. Columns with lower numbers appear first in the layout.
/// @param {Number} $order [0] - Order number to apply.
@mixin flex-grid-order($order: 0) {
  order: $order;
}

/// Horizontally or vertically aligns the columns within a flex row. Apply this mixin to a flex row.
///
/// @param {Keyword} $x [null] - Horizontal alignment to use. Can be `left`, `right`, `center`, `justify`, or `spaced`. Or, set it to `null` (the default) to not set horizontal alignment.
/// @param {Keyword} $y [null] - Vertical alignment to use. Can be `top`, `bottom`, `middle`, or `stretch`. Or, set it to `null` (the default) to not set vertical alignment.
@mixin flex-grid-row-align($x: null, $y: null) {
  @if $x {
    @if map-has-key($-zf-flex-justify, $x) {
      $x: map-get($-zf-flex-justify, $x);
    }
    @else {
      @warn 'flex-grid-row-align(): #{$x} is not a valid value for horizontal alignment. Use left, right, center, justify, or spaced.'
    }
  }

  @if $y {
    @if map-has-key($-zf-flex-align, $y) {
      $y: map-get($-zf-flex-align, $y);
    }
    @else {
      @warn 'flex-grid-row-align(): #{$y} is not a valid value for vertical alignment. Use top, bottom, middle, or stretch.'
    }
  }

  justify-content: $x;
  align-items: $y;
}

/// Vertically align a single column within a flex row. Apply this mixin to a flex column.
///
/// @param {Keyword} $y [null] - Vertical alignment to use. Can be `top`, `bottom`, `middle`, or `stretch`. Or, set it to `null` (the default) to not set vertical alignment.
@mixin flex-grid-column-align($y: null) {
  @if $y {
    @if map-has-key($-zf-flex-align, $y) {
      $y: map-get($-zf-flex-align, $y);
    }
    @else {
      @warn 'flex-grid-column-align(): #{$y} is not a valid value for alignment. Use top, bottom, middle, or stretch.'
    }
  }

  align-self: $y;
}

@mixin foundation-flex-grid {
  // Row
  .row {
    @include flex-grid-row;

    // Nesting behavior
    & & {
      @include flex-grid-row(nest, $base: false);
    }

    // Expanded row
    &.expanded {
      max-width: none;
    }

    &.collapse {
      > .column { @include grid-col-collapse; }
    }
  }

  // Column
  .column {
    @include flex-grid-column;
  }

  // Column row
  // The double .row class is needed to bump up the specificity
  .column.row.row {
    float: none;

    // To properly nest a column row, padding and margin is removed
    .row & {
      padding-left: 0;
      padding-right: 0;
      margin-left: 0;
      margin-right: 0;
    }
  }

  @include -zf-each-breakpoint {
    @for $i from 1 through $grid-column-count {
      // Sizing (percentage)
      .#{$-zf-size}-#{$i} {
        flex: flex-grid-column($i);
        max-width: grid-column($i);
      }

      // Offsets
      $o: $i - 1;

      .#{$-zf-size}-offset-#{$o} {
        @include grid-column-offset($o);
      }
    }

    @for $i from 1 through 6 {
      // Source ordering
      .#{$-zf-size}-order-#{$i} {
        @include flex-grid-order($i);
      }
    }

    @if $-zf-size != small {
      // Sizing (expand)
      @include breakpoint($-zf-size) {
        .#{$-zf-size}-expand {
          flex: flex-grid-column();
        }
      }

      // Auto-stacking/unstacking
      @at-root (without: media) {
        .row.#{$-zf-size}-unstack {
          .column {
            flex: flex-grid-column(100%);

            @include breakpoint($-zf-size) {
              flex: flex-grid-column();
            }
          }
        }
      }
    }

    // Responsive collapsing
    .#{$-zf-size}-collapse {
      > .column { @include grid-col-collapse; }
    }

    .#{$-zf-size}-uncollapse {
      $gutter: null;

      @if $grid-column-gutter {
        $gutter: $grid-column-gutter;
      }
      @else {
        $gutter: -zf-get-bp-val($grid-column-responsive-gutter, $-zf-size);
      }
      > .column { @include grid-col-uncollapse($gutter); }
    }
  }

  // Sizing (shrink)
  .shrink {
    flex: flex-grid-column(shrink);
    max-width: 100%;
  }

  // Horizontal alignment using justify-content
  @each $hdir, $prop in map-remove($-zf-flex-justify, left) {
    .row.align-#{$hdir} {
      @include flex-grid-row-align($x: $hdir);
    }
  }

  // Vertical alignment using align-items and align-self
  @each $vdir, $prop in $-zf-flex-align {
    .row.align-#{$vdir} {
      @include flex-grid-row-align($y: $vdir);
    }

    .column.align-#{$vdir} {
      @include flex-grid-column-align($vdir);
    }
  }

  .columns {
    // scss-lint:disable PlaceholderInExtend
    @extend .column;
  }
}

@include foundation-grid;
// @include foundation-flex-grid;
